<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="小武子博客">
<meta property="og:url" content="http://blog.xiaowuzi.info/page/2/index.html">
<meta property="og:site_name" content="小武子博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小武子博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.xiaowuzi.info/page/2/">





  <title>小武子博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小武子博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2017/11/15/深入理解 Promise (中)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/深入理解 Promise (中)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T20:22:43+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深入理解-Promise-中"><a href="#深入理解-Promise-中" class="headerlink" title="深入理解 Promise (中)"></a>深入理解 Promise (中)</h1><p>这一篇让我们深入源码层面，一步一步去封装一个Promise，去了解Promise的内部实现，以便我们在项目中对Promise的使用运用自如。</p>
<ul>
<li><p>实现一个简单的 Promise工具类</p>
<ul>
<li>Promise类的结构</li>
<li>构造器的初始化</li>
<li>then方法</li>
<li>catch方法</li>
</ul>
</li>
<li><p>添加扩展功能函数</p>
<ul>
<li>all</li>
<li>race</li>
<li>resolve</li>
<li>reject</li>
<li>wait</li>
<li>stop</li>
<li>always</li>
<li>done</li>
<li>defer</li>
<li>timeout</li>
<li>sequence</li>
</ul>
</li>
<li><p>测试</p>
</li>
<li>源码</li>
</ul>
<p>我在想去自己实现一个Promise类库的时候，首先会去找一些比较简洁又符合标准的一些相关实现，去分析其源码，然后结合几种实现的优点总结出自己的版本，站在巨人的肩膀上让我直接取道直径，快速的实现了我的目标，在这里非常感谢前辈们的努力和给我们留下的宝贵知识财富。</p>
<p>从标准中寻找蛛丝马迹 (以下所说的 标准 均以 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 做为参考)，我们将依据标准，编写一个可通过标准测试的Promise类库。</p>
<h2 id="Promise类的结构"><a href="#Promise类的结构" class="headerlink" title="Promise类的结构"></a>Promise类的结构</h2><p>标准中规定：</p>
<ol>
<li>Promise对象初始状态为 Pending，在被 resolve 或 reject 时，状态变为 Fulfilled 或 Rejected</li>
<li>resolve接收成功的数据，reject接收失败或错误的数据</li>
<li>Promise对象必须有一个 then 方法，且只接受两个可函数参数 onFulfilled、onRejected</li>
</ol>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/10/Promise学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/Promise学习/" itemprop="url">Promise学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-10T20:51:07+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Promise 为异步编程提供统一的解决方案，比传统的回调和事件更加合理有效。<br>多重嵌套的回调函数，代码是横向发展，不是纵向发展，容易乱成一团，不便管理，称之为”callback hell”，回调地狱或回调恶梦。<br>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>状态</li>
<li>初始化</li>
<li>then / catch</li>
<li>resolve() / reject()</li>
<li>all() / race()</li>
<li>done / finally</li>
</ul>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise的三个状态：Pending 进行中 / Resolved 已成功 / Rejected 已失败</p>
<p>状态改变方式:</p>
<p>Pending =&gt; Resolved</p>
<p>Pending =&gt; Rejected</p>
<p>将异步操作以同步的操作编程表达出来，避免了层层嵌套的回调函数。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>一旦新建它就会立即执行，无法中途取消</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
</ul>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Promise接收一个函数作为参数，函数的两个参数resolve, reject是两个函数，用于对promise对象的状态改变</li>
<li>resove 将未完成变成已完成 pending =&gt; resolved</li>
<li>reject 将未完成变成已失败 pending =&gt; rejected</li>
</ul>
<h2 id="then-与-catch"><a href="#then-与-catch" class="headerlink" title="then 与 catch"></a>then 与 catch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then()</span><br></pre></td></tr></table></figure>
<p>then方法接收两个函数参数，第一个表示resove 已成功的回调，第二个表示reject 已失败的回调</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123; ... &#125;)</span><br><span class="line">p.then(function()&#123;&#125;, function()&#123;&#125;)</span><br><span class="line">p.then().catch();</span><br></pre></td></tr></table></figure>
<h2 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unction loadImageAsync(url) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    var image = new Image();</span><br><span class="line">    image.onload = function() &#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line">    image.onerror = function() &#123;</span><br><span class="line">      reject(new Error(&apos;Could not load image at &apos; + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loadImagesAsync(&apos;//img.static.com/xxx.jpg&apos;).then(function(img)&#123;</span><br><span class="line">	//加载成功 显示图片</span><br><span class="line">&#125;, function(err)&#123;</span><br><span class="line">	//加载失败 提示失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="异步加载数据"><a href="#异步加载数据" class="headerlink" title="异步加载数据"></a>异步加载数据</h2><p>使用promise包装一个异步请，返回一个promise对象，使用then和catch的方式对返回结果进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var getJSON = function(url)&#123;</span><br><span class="line">	return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">		var client = new XMLHttpRequest();</span><br><span class="line">		client.open(&apos;GET&apos;, url);</span><br><span class="line">		client.onreadystatechange = callback;</span><br><span class="line">		client.send();</span><br><span class="line">		function callback()&#123;</span><br><span class="line">			if(this.readyState !== 4) return;</span><br><span class="line">			if(this.status === 200)&#123;</span><br><span class="line">				resolve(this.response)</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				reject(new Error(this.statusText))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">getJSON(&apos;/api/getList&apos;).then(function(data)&#123;</span><br><span class="line">	//获取请求的数据</span><br><span class="line">&#125;, function(err)&#123;</span><br><span class="line">	//请求失败错误处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>Promise 在实例化的时候就会执行，是一条执行语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">	console.log(&apos;p1 start&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">	console.log(&apos;p2 start&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">// 输出：</span><br><span class="line">// p1 start</span><br><span class="line">// p2 start</span><br></pre></td></tr></table></figure>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>Promise 嵌套，状态改变由最内层的promise对象决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var st, res = true;</span><br><span class="line">var p1 = ()=&gt; new Promise(function (resolve, reject) &#123;</span><br><span class="line">	console.log(&apos;p1 start&apos;)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">  	if(res)&#123;</span><br><span class="line">  		resolve(Date.now() - st +&apos; P1 success&apos;)</span><br><span class="line">  	&#125;else&#123;</span><br><span class="line">  		reject(new Error(Date.now() - st +&apos; P1 fail&apos;));</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">var p2 = ()=&gt; new Promise(function (resolve, reject) &#123;</span><br><span class="line">	st = Date.now()</span><br><span class="line">	console.log(&apos;p2 start&apos;)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">  	if(res)&#123;</span><br><span class="line">  		resolve(p1())</span><br><span class="line">  	&#125;else&#123;</span><br><span class="line">  		reject(new Error(Date.now() - st + &apos; P2 fail&apos;));</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2()</span><br><span class="line">	.then(result =&gt; console.log(result))</span><br><span class="line">	.catch(error =&gt; console.log(error.message))</span><br><span class="line">// 输出：</span><br><span class="line">// p2 start</span><br><span class="line">// Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">// p1 start</span><br><span class="line">// 4002 P1 success</span><br></pre></td></tr></table></figure>
<h2 id="then的调用"><a href="#then的调用" class="headerlink" title="then的调用"></a>then的调用</h2><p>前一个then的返回结果，可以再后一then的回调中获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var p3 = ()=&gt; new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">	resolve(&apos;&#123;&quot;name&quot;:&quot;jack&quot;, &quot;age&quot;:28&#125;&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p3()</span><br><span class="line">	.then(res =&gt; JSON.parse(res))</span><br><span class="line">	.then(data =&gt; Object.assign(data, &#123;name:&apos;rose&apos;&#125;))</span><br><span class="line">	.then(data =&gt; console.log(data))</span><br><span class="line">// 输出：&#123;name: &quot;rose&quot;, age: 28&#125;</span><br><span class="line">var p4 = ()=&gt;&#123;</span><br><span class="line">	var st = Date.now();</span><br><span class="line">	getJSON(&apos;data1.json?delay=1000&apos;)</span><br><span class="line">		.then(data =&gt; &#123;</span><br><span class="line">			console.log(Date.now()-st, data);</span><br><span class="line">			return getJSON(&apos;data2.json?delay=2000&apos;)</span><br><span class="line">		&#125;)</span><br><span class="line">		.then(data =&gt; console.log(Date.now()-st, data))</span><br><span class="line">		.catch(err =&gt; console.log(err.message))</span><br><span class="line">&#125;</span><br><span class="line">p4();</span><br><span class="line">// 1016 &quot;&#123;&quot;status&quot;:&quot;0&quot;&#125;&quot;</span><br><span class="line">// 3028 &quot;&#123;&quot;status&quot;:&quot;1&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Catch"><a href="#Catch" class="headerlink" title="Catch"></a>Catch</h2><p><code>Promise.prototype.catch</code></p>
<p>p.catch()用于处理promise中rejected状态的回调，与p.then(resolveFn, rejectFn)中 rejectFn的作用相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123; ... &#125;);</span><br><span class="line">p.then(function()&#123;&#125;, function()&#123;&#125;);</span><br><span class="line">等同于</span><br><span class="line">p.then(function()&#123;&#125;).catch(function()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>reject(‘error’) 与 throw new Error(‘…’) 都能被catch捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">	throw new Error(&apos;some error1&apos;);</span><br><span class="line">&#125;).catch(err =&gt;  console.log(err.message))</span><br><span class="line">// 等同于</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">	reject(&apos;some error2&apos;)</span><br><span class="line">&#125;).catch(err =&gt; console.log(err))</span><br><span class="line">//输出</span><br><span class="line">// some error1</span><br><span class="line">// some error2</span><br></pre></td></tr></table></figure>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>promise对象的错误，具有 冒泡 性质，会一直向后传递，直到被捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">	throw new Error(&apos;some error1&apos;);</span><br><span class="line">&#125;).then().then().then().catch(err =&gt;  console.log(err.message))</span><br></pre></td></tr></table></figure>
<p>推荐使用 catch 代替then(null, rejectFn)中的rejectFn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">new Promise(function(resolve, reject)&#123;&#125;).then(resolveFn, rejectFn)</span><br><span class="line">// good</span><br><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">&#125;).then(resoveFn).catch(rejectFn)</span><br></pre></td></tr></table></figure>
<p>原因是：catch可以捕获前面then函数返回的错误信息，也更接近同步的写法</p>
<p>promise对象的错误，如果不指定catch来捕获错误，那么错误不会被传递到外层代码（chrome浏览器例外）</p>
<p>catch 返回的是一个promise对象，后面同样可以调用then、catch<br>前面的catch中错误可以被后面的catch捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&apos;err1&apos;)</span><br><span class="line">	.catch(err =&gt; console.log(err))</span><br><span class="line">	.then(() =&gt; console.log(&apos;success&apos;));</span><br><span class="line">// err1</span><br><span class="line">// success</span><br><span class="line">Promise.reject(&apos;err1&apos;)</span><br><span class="line">	.catch(err =&gt; &#123;console.log(err); x+1&#125;)</span><br><span class="line">	.then(() =&gt; console.log(&apos;success&apos;));</span><br><span class="line">Promise.reject(&apos;err1&apos;)</span><br><span class="line">	.catch(err =&gt; &#123;console.log(err); x+1&#125;)</span><br><span class="line">	.catch(err =&gt; console.log(err.message));</span><br><span class="line">// err1</span><br><span class="line">// x is not defined</span><br><span class="line">Promise.resolve(&apos;success1&apos;)</span><br><span class="line">	.catch(err =&gt; console.log(err))</span><br><span class="line">	.then(msg =&gt; console.log(msg));</span><br><span class="line">// success1</span><br></pre></td></tr></table></figure>
<h2 id="all-与-race"><a href="#all-与-race" class="headerlink" title="all 与 race"></a>all 与 race</h2><p><code>Promise.all([])</code>与<code>Promise.race([])</code></p>
<ul>
<li>接收一个数组做为参数，参数中的每个元素为promise实例，</li>
<li>如果元素不是promise实例，则会调用Promise.resolve()转换为promise的实例</li>
<li>将多个promise对象包装为一个新的promise对象</li>
</ul>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><ul>
<li>当p1、p2、p3的状态全部为resolved时，才能将p的状态改为resolved</li>
<li>当p1、p2、p3其中一个状态变成rejected时，就会将p的状态变成rejected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([Promise.resolve(&apos;1&apos;), Promise.resolve(&apos;2&apos;), </span><br><span class="line">Promise.resolve(&apos;3&apos;)]);</span><br><span class="line">p.then(data =&gt; console.log(data)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><span class="line">var p1 = Promise.all([Promise.resolve(&apos;1&apos;), Promise.reject(&apos;2&apos;), </span><br><span class="line">Promise.resolve(&apos;3&apos;)]);</span><br><span class="line">p1.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err)) // 2</span><br></pre></td></tr></table></figure>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>当p1、p2、p3其中一个状态发生改变时，就相应的触发p的状态发生变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;resolve(&apos;p1 success&apos;), 2000))</span><br><span class="line">var p2 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;reject(&apos;p2 error&apos;), 1000))</span><br><span class="line">var p3 = new Promise((resolve, reject)=&gt;setTimeout(()=&gt;resolve(&apos;p3 success&apos;), 3000))</span><br><span class="line">var p = Promise.race([p1, p2, p3]);</span><br><span class="line">p.then(data =&gt; console.log(data)).catch(err =&gt; console.log(err)); //p2 error</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve-与-Promise-reject"><a href="#Promise-resolve-与-Promise-reject" class="headerlink" title="Promise.resolve() 与 Promise.reject()"></a>Promise.resolve() 与 Promise.reject()</h2><p>将普通对象转换为Promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
<p>Pormise.resolve()的四种参数</p>
<ol>
<li>promise实例，则会返回这个实例</li>
<li>含有then方法的对象，则先执行then方法，再返回promise对象</li>
<li>参数是基本类型的值，数据或字符串，则直接resolve这个值</li>
<li>不带参数执行，则返回一个resolved的promise对象</li>
</ol>
<p>Promise.reject()与之类似</p>
<p>Promise.reject()返回一个rejected的promise对象</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Promise.defer 延迟对象，返回一个Promise的实例、resolve、reject方法</p>
<p>defer风格的Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSth() &#123;</span><br><span class="line">    var defer = Promise.defer();</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        defer.resolve();</span><br><span class="line">    &#125;,1000)</span><br><span class="line">    return defer.promise;</span><br><span class="line">&#125;</span><br><span class="line">等同于</span><br><span class="line">doSth = ()=&gt; new Promise((resolve, reject) =&gt; setTimeout( ()=&gt; resolve(&apos;success&apos;), 1000) )</span><br></pre></td></tr></table></figure>
<h2 id="done-与-finally"><a href="#done-与-finally" class="headerlink" title="done 与 finally"></a>done 与 finally</h2><p>添加两个ES6的Promise扩展方法 done()、finally()</p>
<h2 id="done"><a href="#done" class="headerlink" title="done"></a>done</h2><p>done方法: 用于任何可能出现的错误，并向全局抛出。</p>
<p>由于Promise的错误不会冒泡到全局，如果在promise对象的最终then或catch方法中有报错，则无法捕获到。</p>
<p>done()用于promise()尾端调用，可捕获前面未捕获的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.done = function(onResolved, onRejected)&#123;</span><br><span class="line">	this</span><br><span class="line">		.then(onResolved, onRejected)</span><br><span class="line">		.catch(function(err)&#123;</span><br><span class="line">			setTimeout(() =&gt; &#123; throw err&#125;, 0); //抛出一个全局错误</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line">var p = ()=&gt;new Promise((resolve, reject) =&gt; resolve(&apos;success&apos;));</span><br><span class="line">p()</span><br><span class="line">  .then(data =&gt; &#123;console.log(data); x+1;&#125;)</span><br><span class="line">  .catch(err =&gt; &#123;console.log(err.message); y+2;&#125;)</span><br><span class="line">  .then(data =&gt; console.log(data))</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally方法：用于指定不管Promise对象最后状态如何，都会执行的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">	&apos;use strict&apos;;</span><br><span class="line">	let P = this.constructor;</span><br><span class="line">	return this.then(</span><br><span class="line">		value =&gt; P.resolve(callback(value)),</span><br><span class="line">		err =&gt; P.resolve(callback(err))</span><br><span class="line">	);</span><br><span class="line">&#125;;</span><br><span class="line">var p = () =&gt; new Promise((resolve, reject) =&gt; resolve(&apos;success&apos;));</span><br><span class="line">p()</span><br><span class="line">	.then(data =&gt; &#123;console.log(data); x+1;&#125;)</span><br><span class="line">	.catch(err =&gt; &#123;console.log(err.message); y+2;&#125;)</span><br><span class="line">	.then(data =&gt; console.log(data))</span><br><span class="line">	.finally(data =&gt; console.log(data));</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="http://coderlt.coding.me/2016/07/17/ES6-promise/" target="_blank" rel="noopener">ES6笔记 - Promise模式</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise对象</a></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/09/JavaScript之深浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/09/JavaScript之深浅拷贝/" itemprop="url">JavaScript之深浅拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-09T20:51:07+08:00">
                2016-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文要解决的问题：</p>
<ul>
<li>为什么会有深拷贝（deep clone）和浅拷贝（shallow clone）的存在</li>
<li>理解 JavaScript 中深拷贝和浅拷贝的区别</li>
<li>JavaScript 拷贝对象的注意事项</li>
<li>JavaScript 拷贝对象和数组的实现方法</li>
</ul>
<p>部分代码可在这里找到：<a href="https://github.com/chhpt/JavaScript-Exploration/tree/master/shallow-and-deep-copy" target="_blank" rel="noopener">Github</a>。如果发现错误，欢迎指出。</p>
<h2 id="一，-理解问题原因所在"><a href="#一，-理解问题原因所在" class="headerlink" title="一， 理解问题原因所在"></a>一， 理解问题原因所在</h2><p>JavaScript 中的数据类型可以分为两种：基本类型值（Number, Boolean, String, NULL, Undefined）和引用类型值（Array, Object, Date, RegExp, Function)。 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p><strong>基本数据类型是按值访问的</strong>，因为可以直接操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象，与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在<strong>操作对象的引用</strong>而不是实际的对象。 为此，引用类型的值是按引用访问的。</p>
<p>除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同：</p>
<ul>
<li>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</li>
<li>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/04/09/JavaScript之深浅拷贝/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </li></ul></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/08/JavaScript原型与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/08/JavaScript原型与原型链/" itemprop="url">JavaScript原型与原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-08T20:51:07+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原型，作为前端开发者，或多或少都有听说。你可能一直想了解它，但是由于各种原因还没有了解，现在就跟随我来一起探索它吧。本文将由浅入深，一点一点揭开 JavaScript 原型的神秘面纱。（需要了解基本的 JavaScript 对象知识）</p>
<p>源代码：<a href="https://github.com/chhpt/JavaScript-Exploration/tree/master/prototype_and_prototype_chain" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="1-原型是什么？"><a href="#1-原型是什么？" class="headerlink" title="1. 原型是什么？"></a>1. 原型是什么？</h3><p>在我们深入探索之前，当然要先了解原型是什么了，不然一切都无从谈起。谈起原型，那得先从对象说起，且让我们慢慢说起。</p>
<p>我们都知道，JavaScript 是一门基于对象的脚本语言，但是它却没有类的概念，所以 JavaScript 中的对象和基于类的语言（如 Java）中的对象有所不同。JavaScript 中的对象是无序属性的集合，其属性可以包含基本值，对象或者函数，听起来更像是键值对的集合，事实上也比较类似。有了对象，按理说得有继承，不然对象之间没有任何联系，也就真沦为键值对的集合了。那没有类的 JavaScript 是怎么实现继承的呢？</p>
<p>我们知道，在 JavaScript 中可以使用构造函数语法（通过 new 调用的函数通常被称为构造函数）来创建一个新的对象，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">// 构造函数，无返回值</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">// 通过 new 新建一个对象</span><br><span class="line">var person = new Person(&apos;Mike&apos;);</span><br></pre></td></tr></table></figure>
<p>这和一般面向对象编程语言中创建对象（Java 或 C++）的语法很类似，只不过是一种简化的设计，<code>new</code> 后面跟的不是类，而是构造函数。这里的构造函数可以看做是一种类型，就像面向对象编程语言中的类，但是这样创建的对象除了属性一样外，并没有其他的任何联系，对象之间无法共享属性和方法。每当我们新建一个对象时，都会方法和属性分配一块新的内存，这是极大的资源浪费。考虑到这一点，JavaScript 的设计者 Brendan Eich 决定为构造函数设置一个属性。这个属性指向一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面，那些不需要共享的属性和方法，就放在构造函数里面。实例对象一旦创建，将自动引用这个对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，不共享的，另一种是引用的，共享的。这个对象就是原型（prototype）对象，简称为原型。</p>
<p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象就是调用构造函数而创建的对象实例的原型。原型可以包含所有实例共享的属性和方法，也就是说只要是原型有的属性和方法，通过调用构造函数而生成的对象实例都会拥有这些属性和方法。看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = &apos;20&apos;;</span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Jack&apos;);</span><br><span class="line">var person2 = new Person(&apos;Mike&apos;);</span><br><span class="line"></span><br><span class="line">person1.sayName(); // Jack</span><br><span class="line">person2.sayName(); // Mike</span><br><span class="line">console.log(person1.age); // 20</span><br><span class="line">console.log(person2.age); // 20</span><br></pre></td></tr></table></figure>
<p>这段代码中我们声明了一个 <code>Person</code> 函数，并在这个函数的原型上添加了 <code>age</code> 属性和 <code>sayName</code> 方法，然后生成了两个对象实例 <code>person1</code> 和 <code>person2</code>，这两个实例分别拥有自己的属性 <code>name</code> 和原型的属性 <code>age</code> 以及方法 <code>sayName</code>。所有的实例对象共享原型对象的属性和方法，那么看起来，原型对象就像是类，我们就可以用原型来实现继承了。</p>
<h3 id="2-constructor-与-Prototype"><a href="#2-constructor-与-Prototype" class="headerlink" title="2. constructor 与 [[Prototype]]"></a>2. constructor 与 [[Prototype]]</h3><p>我们知道每个函数都有一个 prototype 属性，指向函数的原型，因此当我们拿到一个函数的时候，就可以确定函数的原型。反之，如果给我们一个函数的原型，我们怎么知道这个原型是属于哪个函数的呢？这就要说说原型的 constructor 属性了：</p>
<blockquote>
<p>在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</p>
</blockquote>
<p>也就是说每个原型都有都有一个 constructor 属性，指向了原型所在的函数，拿前面的例子来说 Person.prototype.constructor 指向 Person。下面是构造函数和原型的关系说明图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/14/15fb87e414fdfc08?w=1378&amp;h=514&amp;f=png&amp;s=69237" alt=""></p>
<p>继续，让我们说说 <code>[[prototype]]</code>。</p>
<p>当我们调用构造函数创建一个新的实例（新的对象）之后，比如上面例子中的 <code>person1</code>，实例的内部会包含一个指针（内部属性），指向构造函数的原型。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。我们可与更新函数和原型的关系图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/14/15fb87e414f54951?w=1370&amp;h=938&amp;f=png&amp;s=121320" alt=""></p>
<p>不过在脚本中没有标准的方式访问 [[Prototype]] ， 但在 Firefox、Safari 和 Chrome 中可以通过 <code>__proto__</code>属性访问。而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>
<p>在 VSCode 中开启调试模式，我们可以看到这些关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/14/15fb87e416e2c295?w=826&amp;h=1198&amp;f=png&amp;s=206402" alt=""></p>
<p>从上图中我们可以看到 <code>Person</code> 的 <code>prototype</code> 属性和 <code>person1</code> 的 <code>__proto__</code> 属性是完全一致的，<code>Person.prototype</code> 包含了一个 <code>constructor</code> 属性，指向了 <code>Person</code> 函数。这些可以很好的印证我们上面所说的构造函数、原型、<code>constructor</code> 以及 <code>__proto__</code> 之间的关系。</p>
<h3 id="3-对象实例与原型"><a href="#3-对象实例与原型" class="headerlink" title="3. 对象实例与原型"></a>3. 对象实例与原型</h3><p>了解完构造函数，原型，对象实例之间的关系后，下面我们来深入探讨一下对象和原型之间的关系。</p>
<h4 id="1-判断对象实例和原型之间的关系"><a href="#1-判断对象实例和原型之间的关系" class="headerlink" title="1. 判断对象实例和原型之间的关系"></a>1. 判断对象实例和原型之间的关系</h4><p>因为我们无法直接访问实例对象的 <code>__proto__</code> 属性，所以当我们想要确定一个对象实例和某个原型之间是否存在关系时，可能会有些困难，好在我们有一些方法可以判断。</p>
<p>我们可以通过 <code>isPrototypeOf()</code> 方法判断某个原型和对象实例是否存在关系，或者，我们也可以使用 ES5 新增的方法 <code>Object.getPrototypeOf()</code> 获取一个对象实例 <code>__proto__</code> 属性的值。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">console.log(Person.prototype.isPrototypeOf(person1)); // true</span><br><span class="line">console.log(Object.getPrototypeOf(person1) == Person.prototype); // true</span><br></pre></td></tr></table></figure>
<h4 id="2-对象实例属性和方法的获取"><a href="#2-对象实例属性和方法的获取" class="headerlink" title="2. 对象实例属性和方法的获取"></a>2. 对象实例属性和方法的获取</h4><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例对象中找到了具有给定名字的属性，则返回该属性的值。如果没有找到，则继续搜索 <code>__proto__</code> 指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果在原型对象中找到了这个属性，则返回该属性的值。如果还找不到，就会接着查找原型的原型，直到最顶层为止。这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。我们在实例中添加的一个属性，会屏蔽原型中的同名属性。另外，通过 <code>hasOwnProperty</code> 方法能判断对象实例中是否存在某个属性（不能判断对象原型中是否存在该属性）。来看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">function Person()&#123; &#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Nicholas&apos;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &apos;Software Engineer&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123; console.log(this.name); &#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">// 注意，此处不能用 name，因为函数本身存在 name 属性</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;age&apos;)); // false</span><br><span class="line">console.log(Person.hasOwnProperty(&apos;age&apos;)); // false</span><br><span class="line">person1.name = &apos;Greg&apos;;</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)); // true</span><br><span class="line">console.log(person1.name); //&quot;Greg&quot;——来自实例</span><br><span class="line">console.log(person2.name); //&quot;Nicholas&quot;——来自原型</span><br></pre></td></tr></table></figure>
<h4 id="3-in-操作符"><a href="#3-in-操作符" class="headerlink" title="3. in 操作符"></a>3. in 操作符</h4><p>有两种方式使用 in 操作符：</p>
<ul>
<li><p>单独使用</p>
<blockquote>
<p>在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p>
</blockquote>
</li>
<li><p>for-in 循环中使用。</p>
<blockquote>
<p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性， 也包括存在于原型中的属性。如果需要获取所有的属性（包括不可枚举的属性），可以使用 Object.getOwnPropertyNames() 方法。</p>
</blockquote>
</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">function Person()&#123;</span><br><span class="line">  this.name = &apos;Mike&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &apos;Software Engineer&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123; console.log(this.name); &#125;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">for(var item in person) &#123;</span><br><span class="line">  console.log(item); // name age job sayName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;name&apos; in person); // true - 来自实例</span><br><span class="line">console.log(&apos;age&apos; in person); //  true - 来自原型</span><br></pre></td></tr></table></figure>
<h4 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4. 原型的动态性"></a>4. 原型的动态性</h4><p>由于在对象中查找属性的过程是一次搜索，而实例与原型之间的连接只不过是一个指针，而非一个副本，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = function()&#123; console.log(&quot;hi&quot;); &#125;;</span><br><span class="line">person.sayHi(); // &quot;hi&quot;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先创建了 <code>Person</code> 的一个实例，并将其保存在 <code>person</code> 中。然后，下一条语句在 <code>Person.prototype</code> 中添加了一个方法 <code>sayHi()</code>。即使 <code>person</code> 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。在调用这个方法时，首先会查找 <code>person</code> 实例中是否有这个方法，发现没有，然后到 <code>person</code> 的原型对象中查找，原型中存在这个方法，查找结束。；</p>
<p>但是下面这种代码所得到的结果就完全不一样了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  job: &quot;Software Engineer&quot;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName(); // error</span><br></pre></td></tr></table></figure>
<p>仔细观察上面的代码，我们直接用对象字面量语法给 <code>Person.prototype</code> 赋值，这似乎没有什么问题。但是我们要知道字面量语法会生成一个新的对象，也就是说这里的 <code>Person.prototype</code> 是一个新的对象，和 <code>person</code> 的 <code>__proto__</code> 属性不再有任何关系了。此时，我们再尝试调用 <code>sayName</code> 方法就会报错，因为 <code>person</code> 的 <code>__proto__</code> 属性指向的还是原来的原型对象，而原来的原型对象上并没有 <code>sayName</code> 方法，所以就会报错。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="1-原型的原型"><a href="#1-原型的原型" class="headerlink" title="1. 原型的原型"></a>1. 原型的原型</h3><p>在前面的例子，我们是直接在原型上添加属性和方法，或者用一个新的对象赋值给原型，那么如果我们让原型对象等于另一个类型的实例，结果会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">function Person() &#123;</span><br><span class="line">  this.age = &apos;20&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.weight = &apos;120&apos;;</span><br><span class="line"></span><br><span class="line">function Engineer() &#123;</span><br><span class="line">  this.work = &apos;Front-End&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = new Person();</span><br><span class="line"></span><br><span class="line">Engineer.prototype.getAge = function() &#123;</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">var engineer = new Engineer();</span><br><span class="line"></span><br><span class="line">console.log(person.age); // 20</span><br><span class="line">engineer.getAge(); // 20</span><br><span class="line">console.log(engineer.weight); // 120</span><br><span class="line">console.log(Engineer.prototype.__proto__ == Person.prototype); // true</span><br></pre></td></tr></table></figure>
<p>在上面代码中，有两个构造函数 <code>Person</code> 和 <code>Engineer</code>，可以看做是两个类型，<code>Engineer</code> 的原型是 <code>Person</code> 的一个实例，<strong>也就是说 <code>Engineer</code> 的原型指向了 <code>Person</code> 的原型</strong>（注意上面的最后一行代码）。然后我们分别新建一个 <code>Person</code> 和 <code>Engineer</code> 的实例对象，可以看到 <code>engineer</code> 实例对象能够访问到 <code>Person</code> 的 <code>age</code> 和 <code>weight</code> 属性，这很好理解：<code>Engineer</code> 的原型是 <code>Person</code> 的实例对象，<code>Person</code> 的实例对象包含了 <code>age</code> 属性，而 <code>weight</code> 属性是 <code>Person</code> 原型对象的属性，<code>Person</code> 的实例对象自然可以访问原型中的属性，同理，<code>Engineer</code> 的实例对象 <code>engineer</code> 也能访问 <code>Engineer</code> 原型上的属性，间接的也能访问 <code>Person</code> 原型的属性。</p>
<p>看起来关系有些复杂，不要紧，我们用一张图片来解释这些关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/14/15fb87e414d534ef?w=1362&amp;h=1536&amp;f=png&amp;s=222883" alt=""></p>
<p>是不是一下就很清楚了，顺着图中红色的线，<code>engineer</code> 实例对象可以顺利的获取 <code>Person</code> 实例的属性以及 <code>Person</code> 原型的属性。至此，已经铺垫的差不多了，我们理解了原型的原型之后，也就很容易理解原型链了。</p>
<h3 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2. 原型链"></a>2. 原型链</h3><p>原型链其实不难理解，上图中的红色线组成的链就可以称之为原型链，只不过这是一个不完整的原型链。我们可以这样定义原型链：</p>
<blockquote>
<p>原型对象可以包含一个指向另一个原型（原型2）的指针，相应地，另一个原型（原型2）中也可以包含着一个指向对应构造函数（原型2 的构造函数）的指针。假如另一个原型（原型2）又是另一个类型（原型3 的构造函数）的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
</blockquote>
<p>结合上面的图，这个概念不难理解。上面的图中只有两个原型，那么当有更多的原型之后，这个红色的线理论上可以无限延伸，也就构成了原型链。</p>
<p>通过实现原型链，本质上扩展了前面提到过的原型搜索机制：当以读取模式访问一个实例的属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<p>那么原型链的末端又是什么呢？我们要知道，所有函数的 <code>默认原型</code> 都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code>。我们可以在上面代码的尾部加上一行代码进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">console.log(Person.prototype.__proto__ == Object.prototype); // true</span><br></pre></td></tr></table></figure>
<p>那 <code>Object.prototype</code> 的原型又是什么呢，不可能没有终点啊？聪明的小伙伴可能已经猜到了，没错，就是 <code>null</code>，null 表示此处不应该有值，也就是终点了。我们可以在 Chrome 的控制台或 Node 中验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line">console.log(Object.prototype.__proto__); // null</span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>Constructor：保存着用于创建当前对象的函数。</p>
<p>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定(例如：o.hasOwnProperty(“name”))</p>
<p>isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型。</p>
<p>toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
<p>toString() ：返回对象的字符串表示。</p>
<p>valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。</p>
<p>instanceof 用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上</p>
<p>我们更新一下关系图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/14/15fb87e41507798b?w=2054&amp;h=1454&amp;f=png&amp;s=316686" alt=""></p>
<p>至此，一切已经很清楚了，下面我们来说说原型链的用处。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>《JavaScript 高级程序设计》</li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">Javascript深入之从原型到原型链</a></li>
<li><a href="https://juejin.im/post/5a0a5dc4f265da430b7abffb?utm_source=gold_browser_extension" target="_blank" rel="noopener">深入理解JavaScript之从原型到原型链</a></li>
<li><a href="https://segmentfault.com/a/1190000011880268" target="_blank" rel="noopener">原型图解</a></li>
</ol>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/08/https详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/08/https详解/" itemprop="url">https详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-08T16:45:48+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a><strong>什么是HTTPS</strong></h3><p>   HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL(Secure Socket Layer)和TLS协议代替而已。</p>
<p>   简单理解就是https=http+加密+认证+完整性保护</p>
<h3 id="为什么需要https"><a href="#为什么需要https" class="headerlink" title="为什么需要https"></a><strong>为什么需要https</strong></h3><p>HTTP是明文传输的，也就意味着，介于发送端、接收端中间的任意节点都可以知道你们传输的内容是什么。这些节点可能是路由器、代理等。</p>
<p>举个最常见的例子，用户登陆。用户输入账号，密码，采用HTTP的话，只要在代理服务器上做点手脚就可以拿到你的密码了。</p>
<p><code>用户登陆 --&gt; 代理服务器（做手脚）--&gt; 实际授权服务器</code></p>
<h3 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a><strong>HTTPS过程</strong></h3><p><img src="http://images2015.cnblogs.com/blog/517641/201510/517641-20151004202254433-181254043.png" alt=""></p>
<p>1.客户端发送HTTPS请求给服务器端；</p>
<p>2.服务器端发送CA证书和公钥PublicKey给客户端，注意这个公钥用的是非对称加密钥，只有服务器端才有PublicKey对应的PrivateKey;</p>
<p>3.客户端生成一个会话的密钥SessionKey,注意这个SessionKey是对称密钥，加密解密都是同一个秘钥；<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/04/08/https详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/08/http缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/08/http缓存/" itemprop="url">http缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-08T10:45:48+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="什么是web缓存"><a href="#什么是web缓存" class="headerlink" title="什么是web缓存"></a><strong>什么是web缓存</strong></h3><p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p>
<h3 id="web缓存的作用"><a href="#web缓存的作用" class="headerlink" title="web缓存的作用"></a><strong>web缓存的作用</strong></h3><p>1.减少网络带宽消耗</p>
<p>2.降低服务器压力</p>
<p>3.减少服务器压力</p>
<p>4.减少网络延迟，加快页面打开速度</p>
<h3 id="web缓存的类型"><a href="#web缓存的类型" class="headerlink" title="web缓存的类型"></a><strong>web缓存的类型</strong></h3><p>1.数据库缓存</p>
<p>   Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached redist等。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/04/08/http缓存/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/07/web安全——CRSF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/07/web安全——CRSF/" itemprop="url">web安全——CRSF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-07T21:03:08+08:00">
                2016-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web安全/" itemprop="url" rel="index">
                    <span itemprop="name">web安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/07/javascript引擎的执行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/07/javascript引擎的执行机制/" itemprop="url">javascript引擎的执行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-07T20:51:07+08:00">
                2016-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol>
<li>js为什么是单线程的？为什么需要异步？单线程又是如何实现异步的呢？</li>
<li>js中的event loop(1)</li>
<li>js中的event loop(2)</li>
<li>说说setTimeout</li>
</ol>
<h3 id="一、js为什么是单线程的？为什么需要异步？单线程又是如何实现异步的呢？"><a href="#一、js为什么是单线程的？为什么需要异步？单线程又是如何实现异步的呢？" class="headerlink" title="一、js为什么是单线程的？为什么需要异步？单线程又是如何实现异步的呢？"></a>一、js为什么是单线程的？为什么需要异步？单线程又是如何实现异步的呢？</h3><p>1.1、JS为什么是单线程的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</span><br><span class="line"></span><br><span class="line">场景描述:</span><br><span class="line"></span><br><span class="line">那么现在有2个进程,process1 process2,由于是多进程的JS,所以他们对同一个dom,同时进行操作</span><br><span class="line"></span><br><span class="line">process1 删除了该dom,而process2 编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</span><br></pre></td></tr></table></figure>
<p>这样想,JS为什么被设计成单线程应该就容易理解了吧。</p>
<p>1.2、JS为什么需要异步？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">场景描述:</span><br><span class="line"></span><br><span class="line">如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。</span><br><span class="line">对于用户而言,阻塞就意味着&quot;卡死&quot;,这样就导致了很差的用户体验</span><br></pre></td></tr></table></figure>
<p>所以,JS中存在异步执行。</p>
<p>1.3、JS单线程又是如何实现异步的呢?</p>
<p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?</p>
<p>是通过的事件循环(event loop),理解了event loop机制,就理解了JS的执行机制</p>
<h3 id="二、js中的event-loop-1"><a href="#二、js中的event-loop-1" class="headerlink" title="二、js中的event loop(1)"></a>二、js中的event loop(1)</h3><p>例1，观察它的执行顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure>
<p>运行结果是: 1 3 2</p>
<p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p>
<p>所以,这里我们首先知道了JS里的一种分类方式,就是将任务分为: 同步任务和异步任务</p>
<p>图片描述：<br><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610d76608edbb9b?imageslim" alt="image"></p>
<h4 id="按照这种分类方式-JS的执行机制是"><a href="#按照这种分类方式-JS的执行机制是" class="headerlink" title="按照这种分类方式:JS的执行机制是"></a>按照这种分类方式:JS的执行机制是</h4><ul>
<li>首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table</li>
<li>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</li>
<li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中</li>
</ul>
<p>以上三步循环执行,这就是event loop</p>
<p>所以上面的例子,你是否可以描述它的执行顺序了呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(1) 是同步任务,放入主线程里</span><br><span class="line">setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里</span><br><span class="line">console.log(3 是同步任务,放到主线程里</span><br><span class="line"></span><br><span class="line">当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</span><br></pre></td></tr></table></figure>
<h3 id="三、JS中的event-loop-2"><a href="#三、JS中的event-loop-2" class="headerlink" title="三、JS中的event loop(2)"></a>三、JS中的event loop(2)</h3><p>所以,上面关于event loop就是我对JS执行机制的理解,直到我遇到了下面这段代码</p>
<p>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;定时器开始啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">    for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">        i == 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&apos;执行then函数啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure>
<p>尝试按照,上文我们刚学到的JS执行机制去分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout 是异步任务,被放到event table</span><br><span class="line"></span><br><span class="line">new Promise 是同步任务,被放到主进程里,直接执行打印 console.log(&apos;马上执行for循环啦&apos;)</span><br><span class="line"></span><br><span class="line">.then里的函数是 异步任务,被放到event table</span><br><span class="line"> console.log(&apos;代码执行结束&apos;)是同步代码,被放到主进程里,直接执行</span><br></pre></td></tr></table></figure>
<p>所以,结果是 【马上执行for循环啦 — 代码执行结束 — 定时器开始啦 — 执行then函数啦】吗?</p>
<p>亲自执行后,结果居然不是这样,而是【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p>
<p>那么,难道是异步任务的执行顺序,不是前后顺序,而是另有规定? 事实上,按照异步和同步的划分方式,并不准确。</p>
<p>而准确的划分方式是:</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p><img src="https://segmentfault.com/img/bV1TKz?w=879&amp;h=723" alt=""></p>
<p>按照这种分类方式:JS的执行机制是</p>
<ul>
<li>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里</li>
<li>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</li>
</ul>
<p>重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。</p>
<p>尝试按照刚学的执行机制,去分析例2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里</span><br><span class="line"></span><br><span class="line">遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;</span><br><span class="line"></span><br><span class="line">遇到then方法,是微任务,将其放到微任务的【队列里】</span><br><span class="line"></span><br><span class="line">打印 &quot;代码执行结束&quot;</span><br><span class="line"></span><br><span class="line">本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;</span><br><span class="line"></span><br><span class="line">到此,本轮的event loop 全部完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</span><br></pre></td></tr></table></figure>
<p>所以最后的执行顺序是【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p>
<p>nodejs执行机制</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/07/amd、cmd、common和umd区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/07/amd、cmd、common和umd区别/" itemprop="url">amd、cmd、common和umd区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-07T20:51:07+08:00">
                2016-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/模块化/" itemprop="url" rel="index">
                    <span itemprop="name">模块化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS是同步,服务器端模块的规范，Node.js采用了这个规范。</p>
<p>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// foobar.js</span><br><span class="line">//私有变量</span><br><span class="line">var test = 123; </span><br><span class="line">//公有方法</span><br><span class="line">function foobar () &#123;</span><br><span class="line">    this.foo = function () &#123;</span><br><span class="line">        // do someing ...</span><br><span class="line">    &#125;</span><br><span class="line">    this.bar = function () &#123;</span><br><span class="line">        //do someing ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//exports对象上的方法和变量是公有的</span><br><span class="line">var foobar = new foobar();</span><br><span class="line">exports.foobar = foobar;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//require方法默认读取js文件，所以可以省略js后缀</span><br><span class="line">var test = require(&apos;./boobar&apos;).foobar;</span><br><span class="line">test.bar();</span><br></pre></td></tr></table></figure>
<p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。</p>
<h2 id="AMD和RequireJS"><a href="#AMD和RequireJS" class="headerlink" title="AMD和RequireJS"></a>AMD和RequireJS</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”.</p>
<p>AMD设计出一个简洁的写模块API：<br>define(id?, dependencies?, factory);<br>第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。<br>第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。<br>第三个参数，factory，是一个需要进行实例化的函数或者一个对象。</p>
<p>通过参数的排列组合，这个简单的API可以从容应对各种各样的应用场景，如下所述。</p>
<p>定义无依赖的模块<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/04/07/amd、cmd、common和umd区别/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiaowuzi.info/2016/04/07/http详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小武子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/07/http详解/" itemprop="url">http详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-07T20:45:48+08:00">
                2016-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="http的定义和历史"><a href="#http的定义和历史" class="headerlink" title="http的定义和历史"></a><strong>http的定义和历史</strong></h3><p>  HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前已经经历了四个版本，分别是http0.9，http1.0,http1.1及去年刚发布的http2.0。</p>
<h3 id="http三次握手"><a href="#http三次握手" class="headerlink" title="http三次握手"></a><strong>http三次握手</strong></h3><p>   HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信.</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/CareySon/201204/201204271057008113.png" alt=""></p>
<h3 id="http的主要特点"><a href="#http的主要特点" class="headerlink" title="http的主要特点"></a><strong>http的主要特点</strong></h3><p>1.支持客户/服务器模式<br>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3.灵活：http允许传轮任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4.无连接：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/04/07/http详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Tony</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tony</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>